@using Nalam360Enterprise.UI.Core.Security

@inject IPermissionService? PermissionService
@inject IAuditService? AuditService

@if (!HideIfNoPermission || _hasPermission)
{
    <div class="@GetPinInputClass()" style="@Style" @attributes="@GetHtmlAttributes()">
        @for (int i = 0; i < Length; i++)
        {
            var index = i;
            <input type="@(Mask ? "password" : "text")"
                   class="n360-pininput__box"
                   maxlength="1"
                   value="@GetValueAt(index)"
                   @oninput="e => HandleInputAsync(e, index)"
                   @onkeydown="e => HandleKeyDownAsync(e, index)"
                   @onpaste="HandlePasteAsync"
                   @ref="_inputRefs[index]"
                   disabled="@Disabled"
                   aria-label="@($"PIN digit {index + 1}")" />
            
            @if (i < Length - 1 && (i + 1) % GroupSize == 0)
            {
                <span class="n360-pininput__separator"></span>
            }
        }
    </div>
}

@code {
    [Parameter] public string? Value { get; set; }
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public int Length { get; set; } = 4;
    [Parameter] public int GroupSize { get; set; } = 4;
    [Parameter] public bool Mask { get; set; } = true;
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public PinInputType InputType { get; set; } = PinInputType.Numeric;
    [Parameter] public PinInputSize Size { get; set; } = PinInputSize.Default;
    
    // Events
    [Parameter] public EventCallback<string> OnComplete { get; set; }
    [Parameter] public EventCallback<string> OnChange { get; set; }
    
    // Styling
    [Parameter] public string? CssClass { get; set; }
    [Parameter] public string? Style { get; set; }
    [Parameter] public bool IsRtl { get; set; }
    
    // RBAC
    [Parameter] public string? RequiredPermission { get; set; }
    [Parameter] public bool HideIfNoPermission { get; set; }
    
    // Audit
    [Parameter] public bool EnableAudit { get; set; }
    [Parameter] public string? AuditResource { get; set; }
    
    private bool _hasPermission = true;
    private string[] _digits = new string[4];
    private ElementReference[] _inputRefs = new ElementReference[4];

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(RequiredPermission) && PermissionService != null)
        {
            _hasPermission = await PermissionService.HasPermissionAsync(RequiredPermission);
        }
        
        _digits = new string[Length];
        _inputRefs = new ElementReference[Length];
        
        if (!string.IsNullOrEmpty(Value))
        {
            for (int i = 0; i < Math.Min(Value.Length, Length); i++)
            {
                _digits[i] = Value[i].ToString();
            }
        }
    }

    protected override void OnParametersSet()
    {
        if (Length != _digits.Length)
        {
            _digits = new string[Length];
            _inputRefs = new ElementReference[Length];
        }
    }

    private string GetValueAt(int index)
    {
        return index < _digits.Length ? _digits[index] ?? string.Empty : string.Empty;
    }

    private async Task HandleInputAsync(Microsoft.AspNetCore.Components.ChangeEventArgs e, int index)
    {
        var input = e.Value?.ToString() ?? string.Empty;
        
        if (string.IsNullOrEmpty(input))
        {
            _digits[index] = string.Empty;
            await UpdateValueAsync();
            return;
        }
        
        var lastChar = input[^1].ToString();
        
        if (!IsValidInput(lastChar))
        {
            return;
        }
        
        _digits[index] = lastChar;
        await UpdateValueAsync();
        
        if (index < Length - 1)
        {
            await FocusInputAsync(index + 1);
        }
        else
        {
            var completeValue = string.Join("", _digits);
            if (completeValue.Length == Length && !completeValue.Contains(""))
            {
                await OnComplete.InvokeAsync(completeValue);
                
                if (EnableAudit && AuditService != null)
                {
                    await AuditService.LogAsync(new AuditMetadata
            {
                Action = "PINComplete",
                Resource = AuditResource ?? "PinInput",
                AdditionalData = new Dictionary<string, object> {
                            { "Length", Length }
                        }
            });
                }
            }
        }
    }

    private async Task HandleKeyDownAsync(KeyboardEventArgs e, int index)
    {
        if (e.Key == "Backspace")
        {
            if (string.IsNullOrEmpty(_digits[index]) && index > 0)
            {
                _digits[index - 1] = string.Empty;
                await UpdateValueAsync();
                await FocusInputAsync(index - 1);
            }
            else
            {
                _digits[index] = string.Empty;
                await UpdateValueAsync();
            }
        }
        else if (e.Key == "ArrowLeft" && index > 0)
        {
            await FocusInputAsync(index - 1);
        }
        else if (e.Key == "ArrowRight" && index < Length - 1)
        {
            await FocusInputAsync(index + 1);
        }
    }

    private async Task HandlePasteAsync(ClipboardEventArgs e)
    {
        // Note: Actual paste data would need JS interop
        await Task.CompletedTask;
    }

    private async Task UpdateValueAsync()
    {
        var newValue = string.Join("", _digits);
        Value = newValue;
        await ValueChanged.InvokeAsync(newValue);
        await OnChange.InvokeAsync(newValue);
    }

    private async Task FocusInputAsync(int index)
    {
        // Note: Would require JS interop for actual focus
        await Task.CompletedTask;
    }

    private bool IsValidInput(string input)
    {
        if (string.IsNullOrEmpty(input)) return false;
        
        return InputType switch
        {
            PinInputType.Numeric => char.IsDigit(input[0]),
            PinInputType.Alphabetic => char.IsLetter(input[0]),
            PinInputType.Alphanumeric => char.IsLetterOrDigit(input[0]),
            _ => true
        };
    }

    public async Task ClearAsync()
    {
        _digits = new string[Length];
        await UpdateValueAsync();
        await FocusInputAsync(0);
    }

    private string GetPinInputClass()
    {
        var classes = new List<string> 
        { 
            "n360-pininput",
            $"n360-pininput--{Size.ToString().ToLower()}"
        };
        
        if (Disabled)
        {
            classes.Add("n360-pininput--disabled");
        }
        
        if (Mask)
        {
            classes.Add("n360-pininput--masked");
        }
        
        if (!string.IsNullOrEmpty(CssClass))
        {
            classes.Add(CssClass);
        }
        
        return string.Join(" ", classes);
    }

    private Dictionary<string, object> GetHtmlAttributes()
    {
        var attributes = new Dictionary<string, object>();

        if (IsRtl)
        {
            attributes["dir"] = "rtl";
        }

        attributes["role"] = "group";
        attributes["aria-label"] = "PIN input";

        return attributes;
    }
}
