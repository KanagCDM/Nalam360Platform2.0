@using Syncfusion.Blazor.RichTextEditor
@inject IPermissionService PermissionService
@inject IAuditService AuditService

@if (_hasPermission || !HideIfNoPermission)
{
    <div class="n360-richtexteditor @CssClass" dir="@(IsRtl ? "rtl" : "ltr")">
        <SfRichTextEditor @ref="_editor"
                          Value="@Value"
                          Enabled="@IsEffectivelyEnabled"
                          Readonly="@Readonly"
                          Height="@Height"
                          Width="@Width"
                          Placeholder="@Placeholder"
                          EnableResize="@EnableResize"
                          EnableHtmlEncode="@EnableHtmlEncode"
                          EnableXhtml="@EnableXhtml"
                          MaxLength="@MaxLength"
                          CssClass="@InternalCssClass"
                          ValueChange="@OnValueChangeAsync">
            <RichTextEditorToolbarSettings Items="@ToolbarItems" />
            @ChildContent
        </SfRichTextEditor>
    </div>
}

@code {
    [Parameter] public string? Value { get; set; }
    [Parameter] public EventCallback<string?> ValueChanged { get; set; }
    [Parameter] public bool Enabled { get; set; } = true;
    [Parameter] public bool Readonly { get; set; }
    [Parameter] public string Height { get; set; } = "300px";
    [Parameter] public string Width { get; set; } = "100%";
    [Parameter] public string? Placeholder { get; set; }
    [Parameter] public bool EnableResize { get; set; } = true;
    [Parameter] public bool EnableHtmlEncode { get; set; }
    [Parameter] public bool EnableXhtml { get; set; }
    [Parameter] public int MaxLength { get; set; } = -1;
    [Parameter] public bool ShowCharCount { get; set; } = true;
    [Parameter] public bool EnableAutoUrl { get; set; } = true;
    [Parameter] public bool EnableTabKey { get; set; } = true;
    [Parameter] public RenderFragment? ChildContent { get; set; }
    
    // Toolbar Configuration
    [Parameter] public List<ToolbarItemModel>? CustomToolbarItems { get; set; }
    
    // Styling
    [Parameter] public string? CssClass { get; set; }
    [Parameter] public string? InternalCssClass { get; set; }
    [Parameter] public bool IsRtl { get; set; }
    
    // RBAC
    [Parameter] public string? RequiredPermission { get; set; }
    [Parameter] public bool HideIfNoPermission { get; set; }
    
    // Audit
    [Parameter] public bool EnableAudit { get; set; }
    [Parameter] public string? AuditResource { get; set; }
    
    // Events
    [Parameter] public EventCallback<string> OnChange { get; set; }
    [Parameter] public EventCallback OnActionBegin { get; set; }
    [Parameter] public EventCallback OnActionComplete { get; set; }
    
    private SfRichTextEditor? _editor;
    private bool _hasPermission = true;
    private bool IsEffectivelyEnabled => Enabled && _hasPermission;
    private string Id { get; set; } = Guid.NewGuid().ToString();

    private List<ToolbarItemModel> ToolbarItems => CustomToolbarItems ?? new List<ToolbarItemModel>
    {
        new ToolbarItemModel { Command = ToolbarCommand.Bold },
        new ToolbarItemModel { Command = ToolbarCommand.Italic },
        new ToolbarItemModel { Command = ToolbarCommand.Underline },
        new ToolbarItemModel { Command = ToolbarCommand.StrikeThrough },
        new ToolbarItemModel { Command = ToolbarCommand.Separator },
        new ToolbarItemModel { Command = ToolbarCommand.FontName },
        new ToolbarItemModel { Command = ToolbarCommand.FontSize },
        new ToolbarItemModel { Command = ToolbarCommand.FontColor },
        new ToolbarItemModel { Command = ToolbarCommand.BackgroundColor },
        new ToolbarItemModel { Command = ToolbarCommand.Separator },
        new ToolbarItemModel { Command = ToolbarCommand.Formats },
        new ToolbarItemModel { Command = ToolbarCommand.Alignments },
        new ToolbarItemModel { Command = ToolbarCommand.OrderedList },
        new ToolbarItemModel { Command = ToolbarCommand.UnorderedList },
        new ToolbarItemModel { Command = ToolbarCommand.Separator },
        new ToolbarItemModel { Command = ToolbarCommand.Indent },
        new ToolbarItemModel { Command = ToolbarCommand.Outdent },
        new ToolbarItemModel { Command = ToolbarCommand.Separator },
        new ToolbarItemModel { Command = ToolbarCommand.CreateLink },
        new ToolbarItemModel { Command = ToolbarCommand.Image },
        new ToolbarItemModel { Command = ToolbarCommand.CreateTable },
        new ToolbarItemModel { Command = ToolbarCommand.Separator },
        new ToolbarItemModel { Command = ToolbarCommand.ClearFormat },
        new ToolbarItemModel { Command = ToolbarCommand.SourceCode },
        new ToolbarItemModel { Command = ToolbarCommand.Undo },
        new ToolbarItemModel { Command = ToolbarCommand.Redo }
    };

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(RequiredPermission))
        {
            _hasPermission = await PermissionService.HasPermissionAsync(RequiredPermission);
        }
    }

    private async Task OnValueChangeAsync(Syncfusion.Blazor.RichTextEditor.ChangeEventArgs args)
    {
        Value = args.Value?.ToString();
        await ValueChanged.InvokeAsync(Value);
        await OnChange.InvokeAsync(Value ?? string.Empty);
        
        if (EnableAudit)
        {
            await AuditService.LogAsync(new AuditMetadata
            {
                Action = "ContentChanged",
                Resource = AuditResource ?? $"RichTextEditor-{Id}",
                Timestamp = DateTimeOffset.UtcNow,
                AdditionalData = new Dictionary<string, object>
                {
                    ["ContentLength"] = Value?.Length ?? 0,
                    ["ComponentId"] = Id
                }
            });
        }
    }

    // Public API Methods
    public Task<string> GetHtmlAsync()
    {
        // Return the current value as HTML
        return Task.FromResult(Value ?? string.Empty);
    }

    public async Task<string> GetTextAsync()
    {
        if (_editor != null)
        {
            return await _editor.GetTextAsync() ?? string.Empty;
        }
        return Value ?? string.Empty;
    }

    public async Task RefreshAsync()
    {
        if (_editor != null)
        {
            await _editor.RefreshUIAsync();
        }
    }

    public async Task ExecuteCommandAsync(CommandName command, string? value = null)
    {
        if (_editor != null)
        {
            await _editor.ExecuteCommandAsync(command, value ?? string.Empty);
        }
    }

    public async Task FocusAsync()
    {
        if (_editor != null)
        {
            await _editor.FocusAsync();
        }
    }
}
